// Generated by summon webapp
// Feature module: <%= featureName %>

<% if (featureName === 'router') { -%>
/**
 * Router configuration for <%= name %>
 */
<% if (framework === 'react') { -%>
import { Routes, Route } from 'react-router-dom';

export const AppRoutes = () => (
  <Routes>
    <Route path="/" element={<div>Home</div>} />
    <Route path="/about" element={<div>About</div>} />
    <Route path="*" element={<div>Not Found</div>} />
  </Routes>
);
<% } else { -%>
type RouteHandler = (params: Record<string, string>) => void;

interface Route {
  path: string;
  handler: RouteHandler;
}

const routes: Route[] = [];

export function addRoute(path: string, handler: RouteHandler): void {
  routes.push({ path, handler });
}

export function navigate(path: string): void {
  const route = routes.find((r) => matchPath(r.path, path));
  if (route) {
    const params = extractParams(route.path, path);
    route.handler(params);
    history.pushState(null, '', path);
  }
}

function matchPath(pattern: string, path: string): boolean {
  const regex = new RegExp('^' + pattern.replace(/:\w+/g, '([^/]+)') + '$');
  return regex.test(path);
}

function extractParams(pattern: string, path: string): Record<string, string> {
  const params: Record<string, string> = {};
  const patternParts = pattern.split('/');
  const pathParts = path.split('/');

  patternParts.forEach((part, i) => {
    if (part.startsWith(':')) {
      params[part.slice(1)] = pathParts[i];
    }
  });

  return params;
}

// Listen for popstate events
window.addEventListener('popstate', () => {
  navigate(location.pathname);
});
<% } -%>
<% } else if (featureName === 'state') { -%>
/**
 * State management for <%= name %>
 */
<% if (framework === 'react') { -%>
import { create } from 'zustand';

interface AppState {
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
}

export const useAppStore = create<AppState>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
}));
<% } else { -%>
type Listener<T> = (state: T) => void;

export function createStore<T extends object>(initialState: T) {
  let state = { ...initialState };
  const listeners = new Set<Listener<T>>();

  return {
    getState: () => state,
    setState: (partial: Partial<T>) => {
      state = { ...state, ...partial };
      listeners.forEach((listener) => listener(state));
    },
    subscribe: (listener: Listener<T>) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    },
  };
}

// Application store
export const appStore = createStore({
  count: 0,
});
<% } -%>
<% } else if (featureName === 'api') { -%>
/**
 * API client for <%= name %>
 */
import ky from 'ky';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'https://api.example.com';

export const api = ky.create({
  prefixUrl: API_BASE_URL,
  timeout: 30000,
  retry: {
    limit: 2,
    methods: ['get'],
  },
  hooks: {
    beforeRequest: [
      (request) => {
        // Add auth token if available
        const token = localStorage.getItem('auth_token');
        if (token) {
          request.headers.set('Authorization', `Bearer ${token}`);
        }
      },
    ],
    afterResponse: [
      async (request, options, response) => {
        if (!response.ok) {
          console.error(`API Error: ${response.status} ${response.statusText}`);
        }
        return response;
      },
    ],
  },
});

// Typed API helpers
export async function get<T>(endpoint: string): Promise<T> {
  return api.get(endpoint).json<T>();
}

export async function post<T, D = unknown>(endpoint: string, data: D): Promise<T> {
  return api.post(endpoint, { json: data }).json<T>();
}

export async function put<T, D = unknown>(endpoint: string, data: D): Promise<T> {
  return api.put(endpoint, { json: data }).json<T>();
}

export async function del<T>(endpoint: string): Promise<T> {
  return api.delete(endpoint).json<T>();
}
<% } else if (featureName === 'logging') { -%>
/**
 * Logging utilities for <%= name %>
 */

type LogLevel = 'debug' | 'info' | 'warn' | 'error';

interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: Date;
  context?: Record<string, unknown>;
}

const LOG_LEVELS: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
};

class Logger {
  private minLevel: LogLevel = 'debug';
  private history: LogEntry[] = [];
  private maxHistory = 1000;

  setLevel(level: LogLevel): void {
    this.minLevel = level;
  }

  private log(level: LogLevel, message: string, context?: Record<string, unknown>): void {
    if (LOG_LEVELS[level] < LOG_LEVELS[this.minLevel]) {
      return;
    }

    const entry: LogEntry = {
      level,
      message,
      timestamp: new Date(),
      context,
    };

    this.history.push(entry);
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }

    const styles: Record<LogLevel, string> = {
      debug: 'color: gray',
      info: 'color: blue',
      warn: 'color: orange',
      error: 'color: red',
    };

    console[level === 'debug' ? 'log' : level](
      `%c[${level.toUpperCase()}] ${message}`,
      styles[level],
      context || ''
    );
  }

  debug(message: string, context?: Record<string, unknown>): void {
    this.log('debug', message, context);
  }

  info(message: string, context?: Record<string, unknown>): void {
    this.log('info', message, context);
  }

  warn(message: string, context?: Record<string, unknown>): void {
    this.log('warn', message, context);
  }

  error(message: string, context?: Record<string, unknown>): void {
    this.log('error', message, context);
  }

  getHistory(): LogEntry[] {
    return [...this.history];
  }

  clearHistory(): void {
    this.history = [];
  }
}

export const logger = new Logger();
<% } else { -%>
/**
 * Feature module: <%= featureName %>
 *
 * This is a placeholder for the <%= featureName %> feature.
 * Implement your feature logic here.
 */

export function init<%= pascalCase(featureName) %>(): void {
  console.log('<%= featureName %> feature initialized');
}

export const <%= camelCase(featureName) %> = {
  init: init<%= pascalCase(featureName) %>,
};
<% } -%>
