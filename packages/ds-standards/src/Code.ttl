@prefix : <http://example.org/codestandards#> .
@prefix cs: <http://example.org/codestandards#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# General Code Category
:CodeCategory a cs:Category ;
    rdfs:label "Code"@en ;
    rdfs:comment "General coding standards and best practices"@en .

# Function Scope Standard
:FunctionScope a cs:CodeStandard ;
    cs:name "code/function/scope" ;
    cs:hasCategory :CodeCategory ;
    cs:description "Functions should follow the 'one feature = one function' principle. Each function should handle one specific task. Functions should be pure when possible. Complex operations should be broken down into smaller functions. Functions should be placed close to where they are used." ;
    cs:dos """
(Do) Define functions with a single responsibility:
```typescript
const validateEmail = (email: string): boolean => {
  return /^[^@]+@[^@]+\.[^@]+$/.test(email);
};
```

(Do) Compose single-purpose functions for complex logic:
```typescript
const validateForm = (email: string, password: string): boolean => {
  return validateEmail(email) && validatePassword(password);
};
```

(Do) Place functions close to where they are used in your application logic:
```typescript
class UserService {
  private async validateUser(user: User): Promise<ValidationResult> {
    // validation logic
  }
  async createUser(user: User): Promise<Result> {
    // creation logic
  }
}
```
""" ;
    cs:donts """
(Don't) Mix multiple responsibilities in a single function:
```typescript
const processUser = async (userData: any) => {
  // validation, transformation, DB, notification, cache -- all in one
};
```

(Don't) Create overly generic functions that handle unrelated logic:
```typescript
const handleData = (data: any) => {
  if (data.type === 'user') {
    processUser(data);
  } else if (data.type === 'order') {
    processOrder(data);
  }
};
```
""" .

# API Stability Standard
:APIStability a cs:CodeStandard ;
    cs:name "code/api/stability" ;
    cs:hasCategory :CodeCategory ;
    cs:description "Use @unstable JSDoc tag to mark API stability. Unstable APIs should be clearly marked. Each @unstable tag must include a description. Tags should be in types files. Tags should guide API consumers with clear context." ;
    cs:dos """
(Do) Mark unstable APIs with a clear @unstable JSDoc tag and description:
```typescript
/**
 * Configuration for data processing pipeline
 * @unstable The streaming API is experimental and may change
 * in future releases. Currently only supports JSON data.
 */
interface PipelineConfig {
  // ...
}
```

(Do) Add @unstable tags to specific properties with context:
```typescript
interface PipelineConfig {
  /**
   * @unstable Custom transformers API is in beta, interface may change
   * to support stronger type validation
   */
  transformers?: DataTransformer[];
}
```

(Do) Clearly describe the instability and future plans:
```typescript
interface CacheConfig {
  /**
   * @unstable The distributed cache API is experimental and will be
   * replaced with a new consensus-based implementation in v2.1
   */
  distributed?: boolean;
}
```
""" ;
    cs:donts """
(Don't) Use unclear tags without explanation:
```typescript
interface ProcessorConfig {
  /** @experimental */  // Bad: No context
  streaming?: boolean;
}
```

(Don't) Mix stability tags with regular documentation without context:
```typescript
interface CacheOptions {
  /**
   * Controls cache distribution
   * @unstable  // Bad: No explanation
   */
  mode: 'local' | 'distributed';
}
```

(Don't) Use @unstable tags without describing what's unstable:
```typescript
/**
 * @unstable  // Bad: No description of what's unstable
 */
interface QueueConfig {
  processor: (item: any) => Promise<void>;
}
```

(Don't) Mark stable APIs unnecessarily:
```typescript
interface LoggerConfig {
  /** @stable */  // Bad: No need to mark stable APIs
  level: 'debug' | 'info' | 'error';
}
```
""" .

:FileExportPattern a cs:CodeStandard ;
    cs:name "code/file-export-pattern" ;
    cs:hasCategory :CodeCategory ;
    cs:description "Files should use either a single default export or multiple named exports, based on their domain and purpose. The file name should hint at the type of exports provided. An exception is made for compound components, where named exports can be attached as properties to the default export." ;
    cs:dos """
(Do) Use a single default export for files implementing a single component or function:
```typescript
// ComponentName.tsx
export default ComponentName;
```

(Do) Use multiple named exports for files providing a public API or a collection of related items:
```typescript
// index.ts
export { ComponentA, ComponentB };

// types.ts
export type TypeA = { ... };
export type TypeB = { ... };
```

(Do) Attach named exports to a default export for compound components:
```typescript
// Accordion.tsx
const Accordion = (props) => { /* ... */ };
Accordion.Item = AccordionItem; // Attaching a subcomponent
export default Accordion;
```
""" ;
    cs:donts """
(Don't) Mix default and unrelated named exports in a way that confuses the file's purpose:
```typescript
// Confusing: both default and a disconnected named export
export default ComponentName;
export const helper = () => {};
```

(Don't) Provide multiple unrelated exports from a file meant for a single domain:
```typescript
// Unrelated exports in one file
export default debounce;
export const throttle = () => {};
export const logger = () => {};
```
""" .

:NamedExportsTypeConsistency a cs:CodeStandard ;
    cs:name "code/named-exports-type-consistency" ;
    cs:hasCategory :CodeCategory ;
    cs:description "Files providing named exports should expose a single export shape, except for index.ts files." ;
    cs:dos """
(Do) Export objects that share the same type from a file:
```typescript
export const myFuncA = (value: string) => {};
export const myFuncB = (value: string) => {};
export const myFuncC = (value: string) => {};
```
""" ;
    cs:donts """
(Don't) Export objects of different types or shapes from the same file:
```typescript
export const transformer = (value: string) => {};
export const reducer = (map: string[]) => {};
```

// Or mixing classes and functions
```typescript
export const transformer = (value: string) => {};
class ABC {}
export { ABC };
```
""" .

:NamedExportsReimport a cs:CodeStandard ;
    cs:name "code/named-exports-reimport" ;
    cs:hasCategory :CodeCategory ;
    cs:description "When importing the contents of a file with named exports, use the 'import * as' pattern to conserve the namespace." ;
    cs:dos """
(Do) Use the 'import * as' pattern to conserve the namespace when reimporting named exports:
```typescript
import * as transformers from "./transformers.js";
```
""" ;
    cs:donts """
(Don't) Import named exports directly from a file containing multiple named exports:
```typescript
import { myFunc, otherFunc } from "./transformers.js";
```
""" .
