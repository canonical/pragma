@prefix : <http://example.org/codestandards#> .
@prefix cs: <http://example.org/codestandards#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# General Code Category
:CodeCategory a cs:Category ;
    rdfs:label "Code"@en ;
    rdfs:comment "General coding standards and best practices"@en .

# Function Scope Standard
:FunctionScope a cs:CodeStandard ;
    cs:name "code/function/scope" ;
    cs:hasCategory :CodeCategory ;
    cs:description """Functions should follow the "one feature = one function" principle:
- Each function should handle one specific task
- Functions should be pure when possible
- Complex operations should be broken down into smaller functions
- Functions should be placed close to where they are used""" ;
    cs:dos """# Proper function scoping
```typescript
// Single responsibility functions
const validateEmail = (email: string): boolean => {
  return /^[^@]+@[^@]+\.[^@]+$/.test(email);
};

const validatePassword = (password: string): boolean => {
  return password.length >= 8 && /[A-Z]/.test(password);
};

// Composition of single-purpose functions
const validateForm = (email: string, password: string): boolean => {
  return validateEmail(email) && validatePassword(password);
};

// Clear function boundaries in application logic
class UserService {
  private async validateUser(user: User): Promise<ValidationResult> {
    const basicValidation = validateUserFields(user);
    const roleValidation = await validateUserRoles(user.roles);
    return combineValidations(basicValidation, roleValidation);
  }

  async createUser(user: User): Promise<Result> {
    const validation = await this.validateUser(user);
    if (!validation.isValid) {
      return Result.failure(validation.errors);
    }
    return this.saveUser(user);
  }
}
```

This approach:
- Makes code easier to test
- Improves reusability
- Simplifies maintenance""" ;
    cs:donts """# Problematic function patterns
```typescript
// Don't mix multiple responsibilities
const processUser = async (userData: any) => {  // Bad: Too many responsibilities
  // Input validation
  if (!userData.email || !userData.name) {
    throw new Error('Invalid data');
  }
  
  // Data transformation
  const user = {
    ...userData,
    email: userData.email.toLowerCase(),
    createdAt: new Date()
  };
  
  // Database operation
  const result = await db.users.insert(user);
  
  // Email notification
  await sendWelcomeEmail(user.email);
  
  // Cache update
  await cache.set(`user:${user.id}`, user);
  
  return result;
};

// Don't create overly generic functions
const handleData = (data: any) => {  // Bad: Too generic
  if (data.type === 'user') {
    processUser(data);
  } else if (data.type === 'order') {
    processOrder(data);
  }
  // More conditions...
};
```

These patterns:
- Make testing difficult
- Create maintenance problems
- Reduce code reusability""" .

# API Stability Standard
:APIStability a cs:CodeStandard ;
    cs:name "code/api/stability" ;
    cs:hasCategory :CodeCategory ;
    cs:description """Use @unstable JSDoc tag to mark API stability:
- Unstable APIs should be clearly marked
- Each @unstable tag must include a description
- Tags should be in types files
- Tags should guide API consumers with clear context""" ;
    cs:dos """# Proper stability documentation
```typescript
/**
 * Configuration for data processing pipeline
 * @unstable The streaming API is experimental and may change
 * in future releases. Currently only supports JSON data.
 */
interface PipelineConfig {
  /** 
   * @unstable Custom transformers API is in beta, interface may change
   * to support stronger type validation
   */
  transformers?: DataTransformer[];
  
  /** 
   * @unstable Parallel processing is unstable and may be replaced 
   * with a different concurrency model in v2
   */
  parallel?: boolean;
}

/**
 * Options for cache configuration
 * @unstable The distributed cache API is experimental and will be 
 * replaced with a new consensus-based implementation in v2.1
 */
interface CacheConfig {
  distributed?: boolean;
}
```

This approach:
- Clearly marks unstable features
- Provides context and timeline
- Helps users make informed decisions""" ;
    cs:donts """# Problematic stability documentation
```typescript
// Don't use unclear tags
interface ProcessorConfig {
  /** @experimental */  // Bad: No context
  streaming?: boolean;
}

// Don't mix stability with regular docs
interface CacheOptions {
  /** 
   * Controls cache distribution
   * @unstable  // Bad: No explanation
   */
  mode: 'local' | 'distributed';
}

// Don't use tags without explanation
/**
 * @unstable  // Bad: No description of what's unstable
 */
interface QueueConfig {
  processor: (item: any) => Promise<void>;
}

// Don't mark stable APIs
interface LoggerConfig {
  /** @stable */  // Bad: No need to mark stable APIs
  level: 'debug' | 'info' | 'error';
}
```

These patterns:
- Create confusion
- Provide insufficient context
- Make API stability unclear""" .
