@prefix cso: <http://pragma.canonical.com/codestandards#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# Storybook Category
cs:StorybookCategory a cso:Category ;
    rdfs:label "Storybook"@en ;
    rdfs:comment "Standards for documenting components using Storybook"@en ;
    cso:slug "storybook" .

# Documentation Source Standard
cs:DocumentationSource a cso:CodeStandard ;
    cso:name "storybook/documentation/source" ;
    cso:hasCategory cs:StorybookCategory ;
    cso:description "Component documentation must primarily come from TSDoc comments on the component signature and props. Storybook docs overrides should only be used when the documentation needs to differ between code and Storybook contexts." ;
    cso:dos """
(Do) Use TSDoc comments for primary documentation.
```typescript

// ContextualMenu/types.ts
export interface ContextualMenuProps extends HTMLAttributes<HTMLDivElement> {
  /** The element that triggers the contextual menu */
  children: ReactElement;
  /** The items to display in the contextual menu */
  items: MenuItem[];
}

// ContextualMenu/ContextualMenu.tsx
/**
 * A wrapper component that adds a contextual menu to its children.
 * The menu appears when the children are clicked or activated via keyboard.
 */
const ContextualMenu = ({
  children,
  items,
}: ContextualMenuProps): ReactElement => {
  // ...
};
```
""" ;
    cso:donts """
(Don't) Add documentation in Storybook parameters when TSDoc is sufficient.
```typescript
export const Default: Story = {
  parameters: {
    docs: {
      description: {
        component: "A wrapper component that adds a contextual menu to its children" // Covered in TSDoc
      }
    }
  }
};
```
""" .

# Story Visibility Standard
cs:StoryVisibility a cso:CodeStandard ;
    cso:name "storybook/story/visibility" ;
    cso:hasCategory cs:StorybookCategory ;
    cso:description "Stories that exist solely for testing or visual coverage but don't represent valid usage patterns must be hidden from documentation and the sidebar using tags." ;
    cso:dos """
(Do) Hide test-only stories that don't represent valid usage.
```typescript
export const FocusedState: Story = {
  args: {
    isOpen: true,
    children: "Test Content"
  },
  tags: ["!dev", "!autodocs"],
  play: async ({ canvasElement }) => {
    const element = canvasElement.querySelector(".component");
    element.focus();
  }
};
```
""" ;
    cso:donts """
(Don't) Show implementation details or test states in documentation.
```typescript
export const InternalTestState: Story = {
  args: {
    _internalProp: true,  // Bad: Exposing internal state
    children: "Test"
  },
  parameters: {
    docs: {
      description: { story: "Tests internal state" }  // Bad: Implementation detail
    }
  }
};
```
""" .

# Story Format Standard
cs:StoryFormat a cso:CodeStandard ;
    cso:name "storybook/story/format" ;
    cso:hasCategory cs:StorybookCategory ;
    cso:description """Stories must use one of three formats, each serving specific needs:
1. CSF3 (object-based) format must be used for standard component variations where args define the component state.
2. Function-based format must be used when the story needs to directly control component rendering or wrap the component with custom elements.
3. Template-based format must be used when multiple stories share the same logic but differ in their args.""" ;
    cso:dos """
(Do) Use the format that matches your specific use case.
```typescript
// CSF3: For standard component variations through args
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    variant: "primary",
    children: "Click me",
    disabled: false
  }
};

// Function-based: When story needs dynamic rendering logic
export const WithDynamicChildren = (args: ComponentProps) => {
  const [items] = useState(["Item 1", "Item 2"]);
  return (
    <Component {...args}>
      {items.map((item) => (
        <ListItem key={item}>{item}</ListItem>
      ))}
    </Component>
  );
};

// Template-based: When multiple stories share logic
const Template: StoryFn<typeof Component> = (args) => (
  <div className="button-container">
    <Label>Button:</Label>
    <Component {...args} />
  </div>
);

export const Primary = Template.bind({});
Primary.args = { variant: "primary" };
```
""" ;
    cso:donts """
(Don't) Use a format that doesn't match your use case.
```typescript
// Bad: Using function format for simple args variation
export const SimpleButton = () => (
  <Component variant="primary" disabled={false}>
    Click me
  </Component>
);

// Bad: Duplicating complex logic without template
export const First: Story = {
  decorators: [(Story) => (
    <div className="button-container">
      <Label>Button:</Label>
      <Story />
    </div>
  )]
};
```
""" .

# Story Decorator Standard
cs:StoryDecorator a cso:CodeStandard ;
    cso:name "storybook/story/decorator" ;
    cso:hasCategory cs:StorybookCategory ;
    cso:description "Decorators must be used to wrap stories in common context providers or layout elements. Decorators must be defined in `storybook/decorators.tsx` and be imported as `decorators` in the storybook file." ;
    cso:dos """
(Do) Use decorators for static context or layout wrapping.
```typescript

// storybook/decorators.tsx

export const theme = (Story: StoryFn<typeof Component>) => (
  <ThemeProvider theme="dark">
    <Story />
  </ThemeProvider>
);

export const config = (Story: StoryFn<typeof Component>) => (
  <ConfigProvider locale="en">
    <Story />
  </ConfigProvider>
);

// src/ui/<ComponentName>/<ComponentName>.stories.tsx

import * as decorators from "storybook/decorators.js";
export const WithTheme: Story = {
  decorators: [decorators.theme],
  args: {
    variant: "primary"
  }
};

// Component-level decorator in meta, applies to all stories in this file.
const meta = {
  decorators: [decorators.config],
} satisfies Meta<typeof Component>;

export default meta;
```
""" ;
    cso:donts """
(Don't) Use function-based stories for static wrapping that could be done with decorators.
```typescript
// Bad: Using function-based story for static wrapping
export const WithTheme = (args: ComponentProps) => (
  <ThemeProvider theme="dark">
    <Component {...args} />
  </ThemeProvider>
);
```

(Don't) define decorators directly in a story file.
```typescript
// Bad: Defining decorators directly in the story file
export const WithTheme: Story = {
  decorators: [(Story) => (
    <ThemeProvider theme="dark">
      <Story />
    </ThemeProvider>
  )],
  // ....
}
```
""" .

# Story Import Standard
cs:StoryImport a cso:CodeStandard ;
    cso:name "storybook/story/import" ;
    cso:hasCategory cs:StorybookCategory ;
    cso:description "Stories must import their component as 'Component' to maintain a consistent, generic reference that is decoupled from the specific component name." ;
    cso:dos """
(Do) Import the component generically as 'Component'.
```typescript
import Component from "./SkipLink.js";

const meta = {
  title: "SkipLink",
  component: Component,
} satisfies Meta<typeof Component>;

export const Default: Story = {
  args: {
    children: "Skip to main content"
  }
};
```
""" ;
    cso:donts """
(Don't) Import the component using its specific name.
```typescript
import SkipLink from "./SkipLink.js";

const meta = {
  title: "SkipLink",
  component: SkipLink,  // Bad: Using specific component name
} satisfies Meta<typeof SkipLink>;
```
""" .

# Story Organization Standard
cs:StoryOrganization a cso:CodeStandard ;
    cso:name "storybook/story/organization" ;
    cso:hasCategory cs:StorybookCategory ;
    cso:description "Stories must be organized into logical groups that demonstrate related features and variations. Each story should focus on a specific use case or feature, with clear naming that indicates what aspect of the component it demonstrates." ;
    cso:dos """
(Do) Group related features with clear, descriptive names.
```typescript
// Basic usage
export const Default: Story = {
  args: {
    mainId: "main",
    children: "Skip to main content"
  }
};

// Custom element targeting
export const CustomMainElement: Story = {
  args: {
    mainId: "my-main-element",
    children: "Skip to main content"
  }
};

// Content customization
export const CustomText: Story = {
  args: {
    mainId: "main",
    children: "Jump to content"
  }
};
```
""" ;
    cso:donts """
(Don't) Use unclear names or mix unrelated features in a single story.
```typescript
// Bad: Unclear what this story demonstrates
export const Variant1: Story = {
  args: {
    mainId: "custom",
    children: "Skip",
    className: "special",
    onClick: () => {},
    style: { color: "red" }
  }
};
```
""" .

# Story Testing Standard
cs:StoryTesting a cso:CodeStandard ;
    cso:name "storybook/story/testing" ;
    cso:hasCategory cs:StorybookCategory ;
    cso:description "Stories that test component behavior must use the `play` function to simulate user interactions and verify expected outcomes." ;
    cso:dos """
(Do) Use play functions to test interactive behavior.
```typescript
export const InteractionTest: Story = {
  args: {
    children: "Click Me",
    onClick: () => {}
  },
  play: async ({ canvasElement, args }) => {
    const button = canvasElement.querySelector("button");
    await userEvent.click(button);
    await expect(args.onClick).toHaveBeenCalled();
  }
};
```
""" ;
    cso:donts """
(Don't) Test implementation details or internal state.
```typescript
export const InternalTest: Story = {
  play: async ({ component }) => {
    // Bad: Testing internal implementation
    expect(component._internalState).toBe(true);
  }
};
```
""" .

# Story Documentation Standard
cs:StoryDocumentation a cso:CodeStandard ;
    cso:name "storybook/story/documentation" ;
    cso:hasCategory cs:StorybookCategory ;
    cso:description "Story documentation must focus on usage patterns and variations, not implementation details. Each story should demonstrate a specific use case or variation." ;
    cso:dos """
(Do) Document usage patterns and variations.
```typescript
export const WithCustomTrigger: Story = {
  args: {
    trigger: <button>Custom Trigger</button>
  },
  parameters: {
    docs: {
      description: {
        story: "The component accepts a custom trigger element to replace the default button."
      }
    }
  }
};
```
""" ;
    cso:donts """
(Don't) Document implementation details or internal behavior.
```typescript
export const Default: Story = {
  parameters: {
    docs: {
      description: {
        story: "Uses React.createPortal internally to render the popup" // Bad: Implementation detail
      }
    }
  }
};
```
""" .

# Story Naming Standard
cs:StoryNaming a cso:CodeStandard ;
    cso:name "storybook/story/naming" ;
    cso:hasCategory cs:StorybookCategory ;
    cso:description "Story names must be descriptive and follow a consistent pattern. Use PascalCase for story exports and natural language for story titles." ;
    cso:dos """
(Do) Use clear, descriptive names that indicate the variation.
```typescript
export const WithCustomStyles: Story = {
  args: {
    className: "custom",
    children: "Styled Content"
  },
  parameters: {
    docs: {
      description: {
        story: "Demonstrates custom styling options"
      }
    }
  }
};
```
""" ;
    cso:donts """
(Don't) Use technical or implementation-focused names.
```typescript
export const TestCase1: Story = {  // Bad: Non-descriptive name
  args: {
    _testFlag: true,  // Bad: Implementation detail
    children: "Content"
  }
};
```
""" .
