@prefix cso: <http://pragma.canonical.com/codestandards#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# General Code Category
cs:CodeCategory a cso:Category ;
    rdfs:label "Code"@en ;
    rdfs:comment "General typescript coding standards and best practices"@en ;
    cso:slug "code" .

# Function Purity Standard
cs:FunctionPurity a cso:CodeStandard ;
    cso:name "code/function/purity" ;
    cso:hasCategory cs:CodeCategory ;
    cso:description "Functions should be pure where possible. A pure function returns the same output for the same input and does not modify external state or perform I/O operations. If a function must perform side effects (e.g., I/O in CLI tools), it must be explicitly annotated and documented with the reason for impurity using the industry-standard @remarks or @note tag in TSDoc/JSDoc." ;
    cso:dos """
(Do) Create pure functions that rely only on their inputs to compute the output.
```typescript
const calculatePrice = (basePrice: number, taxRate: number): number => {
  return basePrice * (1 + taxRate);
};
```

(Do) Annotate and document impure functions that perform I/O or modify external state, explaining why impurity is necessary using @remarks or @note.
```typescript
/**
 * Writes data to the file system.
 * @remarks
 * This function performs I/O and is impure. It will modify external state.
 */
function writeOutputToFile(data: string, path: string) {
  fs.writeFileSync(path, data);
}
```
""" ;
    cso:donts """
(Don't) Create impure functions without annotation or documentation.
```typescript
let total = 0;
const addToTotal = (value: number) => {
  total += value; // Modifies external state, not documented
};
```

(Don't) Hide side effects in functions that appear pure.
```typescript
function getConfig() {
  // Reads from disk without annotation
  return fs.readFileSync('config.json');
}
```
""" .

# Function Composition Standard
cs:FunctionComposition a cso:CodeStandard ;
    cso:name "code/function/composition" ;
    cso:hasCategory cs:CodeCategory ;
    cso:description "Each function must handle exactly one specific task. Complex operations must be broken down into smaller, single-purpose functions." ;
    cso:dos """
(Do) Define functions with a single, clear responsibility.
```typescript
const validateEmail = (email: string): boolean => {
  return /^[^@]+@[^@]+\.[^@]+$/.test(email);
};
```

(Do) Compose single-purpose functions to build complex logic.
```typescript
const validatePassword = (password: string): boolean => {
  return password.length >= 8;
};

const validateForm = (email: string, password:string): boolean => {
  return validateEmail(email) && validatePassword(password);
};
```
""" ;
    cso:donts """
(Don't) Mix multiple responsibilities in a single function.
```typescript
const processUserData = (user: any) => {
  // Validates user data
  // Transforms the data
  // Saves to the database
  // Sends a notification
};
```
""" .

# Function Location Standard
cs:FunctionLocation a cso:CodeStandard ;
    cso:name "code/function/location" ;
    cso:hasCategory cs:CodeCategory ;
    cso:description "Functions must be defined as close to their broadest point of use as possible. Shared utilities must be placed in a common location, and each function must serve a single feature or responsibility." ;
    cso:dos """
(Do) Place functions in the file or module where they are most broadly used. If a function is shared across multiple components or modules, place it in a common utility location.
```typescript
// utils/math.ts
export function calculateSum(a: number, b: number): number {
  return a + b;
}

// Used in multiple places
import { calculateSum } from './utils/math.js';

// For single-use functions, keep them close to their usage:
```typescript
const formatUserName = (user: User) => `${user.firstName} ${user.lastName}`;
""" ;
    cso:donts """
(Don't) Place functions far from where they are used, or in a generic location if only used in one place.
```typescript
// utils/validators.ts
export const validateUser = (user: User) => { ... }; // Only used in one component

// services/UserService.ts
import { validateUser } from '../utils/validators.js'; // Less ideal if only used here

// Don't mix unrelated functions in a single file:
```typescript
export const mathFunc = () => {};
export const stringFunc = () => {};
""" .

# API Stability Standard
cs:APIStability a cso:CodeStandard ;
    cso:name "code/api/stability" ;
    cso:hasCategory cs:CodeCategory ;
    cso:description "Experimental APIs must be marked with the @experimental JSDoc tag in type definition files. The tag must include a description of what is experimental." ;
    cso:dos """
(Do) Mark an experimental interface with a clear @experimental JSDoc tag and description.
```typescript
/**
 * Configuration for the data processing pipeline.
 * @experimental The streaming API is experimental and may change
 * in future releases. Currently, it only supports JSON data.
 */
interface PipelineConfig {
  // ...
}
```

(Do) Add an @experimental tag to a specific property with context about its experimental status.
```typescript
interface PipelineConfig {
  /**
   * @experimental The custom transformers API is in beta, and the interface
   * may change to support stronger type validation.
   */
  transformers?: DataTransformer[];
}
```

(Do) Describe the experimental status and any future plans for the API.
```typescript
interface CacheConfig {
  /**
   * @experimental The distributed cache API is experimental and will be
   * replaced with a new consensus-based implementation in v2.1.
   */
  distributed?: boolean;
}
```
""" ;
    cso:donts """
(Don't) Use the @experimental tag without an explanation.
```typescript
interface ProcessorConfig {
  /** @experimental */ // Bad: No context provided.
  streaming?: boolean;
}
```

(Don't) Use the @experimental tag without describing what is experimental.
```typescript
/**
 * @experimental // Bad: No description of what is experimental.
 */
interface QueueConfig {
  processor: (item: any) => Promise<void>;
}
```
""" .

cs:ExportShape a cso:CodeStandard ;
    cso:name "code/export/shape" ;
    cso:hasCategory cs:CodeCategory ;
    cso:description "Files must use either a single default export or multiple named exports. When using multiple named exports, all exports must have the same type or shape." ;
    cso:dos """
(Do) Use a single default export for files implementing a single component or function:
```typescript
// ComponentName.tsx
export default ComponentName;
```

(Do) Use multiple named exports for files providing a public API or a collection of related items, and ensure all exports have the same type:
```typescript
// index.ts
export { ComponentA, ComponentB };

// types.ts
export type TypeA = { ... };
export type TypeB = { ... };

// Consistent export shape:
export const myFuncA = (value: string) => {};
export const myFuncB = (value: string) => {};
export const myFuncC = (value: string) => {};
```
""" ;
    cso:donts """
(Don't) Mix default and unrelated named exports in a way that confuses the file's purpose:
```typescript
export default ComponentName;
export const helper = () => {};
```

(Don't) Provide multiple unrelated exports from a file meant for a single domain:
```typescript
export default debounce;
export const throttle = () => {};
export const logger = () => {};
```

(Don't) Export objects of different types or shapes from the same file:
```typescript
export const transformer = (value: string) => {};
export const reducer = (map: string[]) => {};
class ABC {}
export { ABC };
```
""" .
