@prefix : <http://pragma.canonical.com/codestandards#> .
@prefix cs: <http://pragma.canonical.com/codestandards#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# React Category
:ReactCategory a cs:Category ;
    rdfs:label "React"@en ;
    rdfs:comment "Standards specific to React development"@en .

# Component Folder Structure Standard
:ComponentFolderStructure a cs:CodeStandard ;
    cs:name "react/component/folder-structure" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Each component must reside in its own folder, which contains all related files, including the component implementation, stories, tests, styles, and type definitions. This colocation improves discoverability and maintainability." ;
    cs:dos """
(Do) Place all files related to a single component within the same component folder.
```
MyComponent/
  ├── MyComponent.tsx
  ├── MyComponent.stories.tsx
  ├── MyComponent.tests.tsx
  ├── index.ts
  ├── styles.css
  └── types.ts
```
""" ;
    cs:donts """
(Don't) Place multiple components in the same folder.
```
MyComponent/
  ├── MyComponent.tsx
  ├── AnotherComponent.tsx   # Bad: Should be in its own folder
  └── index.ts
```

(Don't) Omit the `index.ts` file for barrel exports.
```
MyComponent/
  ├── MyComponent.tsx
  # Bad: Missing index.ts
```
""" .

# Component Folder Naming Standard
:ComponentFolderNaming a cs:CodeStandard ;
    cs:name "react/component/folder-naming" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Component folders must be named using PascalCase (e.g., `Button`, `Tooltip`). This convention ensures consistency with the component's own name." ;
    cs:dos """
(Do) Name the component folder using PascalCase.
```
MyComponent/
Tooltip/
Button/
```
""" ;
    cs:donts """
(Don't) Use kebab-case or snake_case for component folder names.
```
my-component/
tooltip_folder/
```
""" .

# Component File Naming Standard
:ComponentFileNaming a cs:CodeStandard ;
    cs:name "react/component/file-naming" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Files within a component's folder must be named after the component, using the format `ComponentName.filetype.tsx`. For example, `MyComponent.stories.tsx`." ;
    cs:dos """
(Do) Name files using the component's name as a prefix.
```
MyComponent/
  ├── MyComponent.tsx
  ├── MyComponent.stories.tsx
  ├── MyComponent.tests.tsx
```
""" ;
    cs:donts """
(Don't) Use generic or inconsistent file names.
```
MyComponent/
  ├── main.tsx           # Bad: Not named after the component
  ├── story.tsx          # Bad: Not named after the component
  ├── test.tsx           # Bad: Not named after the component
```
""" .

# Component Props Typing Standard
:ComponentPropsTyping a cs:CodeStandard ;
    cs:name "react/component/props-typing" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Component props must be explicitly typed using TypeScript interfaces. This ensures type safety and provides clear documentation for the component's API." ;
    cs:dos """
(Do) Define an interface for the component's props.
```typescript
interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
}

const Button = ({ label, onClick, variant = 'primary' }: ButtonProps) => {
  // ...
};
```
""" ;
    cs:donts """
(Don't) Use `any` for prop types.
```typescript
const Button = (props: any) => {
  // ...
};
```

(Don't) Destructure props without providing a type.
```typescript
const Button = ({ label, onClick }) => {
  // ...
};
```
""" .

# Component Props Naming Standard
:ComponentPropsNaming a cs:CodeStandard ;
    cs:name "react/component/props-naming" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Prop names should be semantic and clearly describe their purpose. Avoid single-letter or ambiguous names." ;
    cs:dos """
(Do) Use descriptive names for props.
```typescript
interface ButtonProps {
  label: string;
  onClick: () => void;
}
```
""" ;
    cs:donts """
(Don't) Use non-semantic or unclear prop names.
```typescript
interface ButtonProps {
  a: string;      // Bad: Not descriptive
  b: () => void;  // Bad: Not descriptive
}
```
""" .

# Component Naming Standard
:ComponentNaming a cs:CodeStandard ;
    cs:name "react/component/naming" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Components should use PascalCase naming and be descriptive of their purpose." ;
    cs:dos """
(Do) Use PascalCase and descriptive names for components:
UserProfile
NavigationBar
SearchResultList
""" ;
    cs:donts """
(Don't) Use non-PascalCase or unclear names:
userProfile
navigation_bar
searchresultlist
""" .

# Hook Naming Standard
:HookNaming a cs:CodeStandard ;
    cs:name "react/hook/naming" ;
    cs:hasCategory :ReactCategory ;
    cs:description "The hook name must start with 'use' and clearly describe its purpose." ;
    cs:dos """
(Do) Name custom hooks so the hook name starts with 'use' and is descriptive:
```typescript
useWindowSize()
useAuthentication()
useFormValidation()
```
""" ;
    cs:donts """
(Don't) Name hooks without the 'use' prefix at the start of the hook name:
```typescript
windowSize()
getAuth()
formValidation()
```
""" .

# Context Shortcut Hook Naming Standard
:ContextShortcutHookNaming a cs:CodeStandard ;
    cs:name "react/hook/naming/context-shortcuts" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Context shortcut hooks should use the pattern useContextName, where the hook name starts with 'use' followed by the context name in PascalCase (e.g., useApplicationSettings)." ;
    cs:dos """
(Do) Name context shortcut hooks so the hook name starts with 'use' and follows the pattern useContextName:
```typescript
useApplicationSettings()
useUserPreferences()
useThemeContext()
```
""" ;
    cs:donts """

(Don't) Use unclear or generic names for context shortcut hooks:
```typescript
settingsContext()
preferences()
theme()
```
""" .

# Component Dependencies Standard
:ComponentDependencies a cs:CodeStandard ;
    cs:name "react/component/dependencies" ;
    cs:hasCategory :ReactCategory ;
    cs:description """Component dependencies must follow a strict unidirectional flow. Subcomponents should be organized in a `common/` folder within the parent component's directory. Dependencies can flow downwards (parent to subcomponent) or sideways (subcomponent to sibling), but never upwards (subcomponent to parent). This prevents circular dependencies and improves modularity.""" ;
    cs:dos """
(Do) Place subcomponents in a `common/` folder inside the parent component directory.
```
Card/
  ├── Card.tsx
  ├── common/
  │   ├── Header/
  │   │   └── Header.tsx
  │   ├── Footer/
  │   │   └── Footer.tsx
  │   └── utils/
  │       └── helpers.ts
  └── index.ts
```

(Do) Allow subcomponents to depend on siblings or shared utilities within the same component scope.
```typescript
// Header.tsx can import from utils/
import { helper } from '../utils/helpers';

// Footer.tsx can import from Header.tsx
import Header from '../Header';
```
""" ;
    cs:donts """
(Don't) Create dependencies that flow upwards from a subcomponent to its parent.
```typescript
// Bad: Header.tsx in Card/common/ should not import from Card.tsx
import Card from '../../Card';
```

(Don't) Allow external components to depend on the internal structure of another component.
```typescript
// Bad: AnotherComponent should not import from Card's internal common folder
import Header from '../Card/common/Header';
```
""" .

# Subcomponents Export and Consumption API Standard
:SubcomponentsExportAPI a cs:CodeStandard ;
    cs:name "react/component/subcomponents/export-api" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Public subcomponents should be exported by attaching them to the parent component using dot notation and semantic names. Private subcomponents remain internal. Consumers should use dot notation to access public subcomponents, with flat, semantic hierarchy." ;
    cs:dos """
(Do) Export public subcomponents by attaching them to the parent component using dot notation:
```typescript
const Item = (props: ItemProps) => { /* ... */ };
const Accordion = (props: AccordionProps) => { /* ... */ };
Accordion.Item = Item;
export default Accordion;
```

(Do) Use semantic, self-descriptive names for subcomponents:
```typescript
Accordion.Item
Card.Header
Card.Footer
```

(Do) Keep subcomponent nesting to a single level:
```typescript
<Card>
  <Card.Header />
  <Card.Footer />
</Card>
```

(Do) Keep private subcomponents internal and do not export them:
```typescript
// Only export subcomponents intended for public use
// Private subcomponents remain unexported
```
""" ;
    cs:donts """
(Don't) Repeat the parent component name in subcomponent names:
```typescript
Card.CardHeader = Header; // Bad: Redundant 'Card' prefix
```

(Don't) Map a subcomponent to a different name (renaming):
```typescript
Card.Top = Header; // Bad: Mapping 'Header' to 'Top' is not allowed
```

(Don't) Use non-semantic or unclear subcomponent names:
```typescript
Card.Part1 = Section; // Bad: 'Part1' is not descriptive
```

(Don't) Create deeply nested subcomponent hierarchies:
```typescript
<Card>
  <Card.Section>
    <Card.Section.Header>
      <Card.Section.Header.Title /> // Bad: Too deep
    </Card.Section.Header>
  </Card.Section>
</Card>
```


(Don't) Export private subcomponents that are not intended for public use.
```typescript
// Bad: Exporting internal-only subcomponents
export { InternalHelper };
```
""" .

# CSS ClassName Ordering Standard
:ClassNameOrdering a cs:CodeStandard ;
    cs:name "react/component/classname-ordering" ;
    cs:hasCategory :ReactCategory ;
    cs:description "The `className` prop must be the last class applied in a component's class list. This ensures that consumer-provided classes can reliably override component styles due to CSS specificity rules." ;
    cs:dos """
(Do) Apply the `className` prop at the end of the class list to ensure correct style overrides.
```tsx
const Rule = ({ className, emphasis, ...props }: RuleProps) => (
  <hr
    className={[
      "ds rule",     // Base component classes
      emphasis,      // Modifier classes
      className      // Consumer classes (last)
    ].filter(Boolean).join(" ")}
    {...props}
  />
);
```
""" ;
    cs:donts """
(Don't) Place the `className` prop before other classes in the list.
```tsx
const Rule = ({ className, emphasis, ...props }: RuleProps) => (
  <hr
    className={[
      className,     // Bad: Consumer classes appear first
      "ds rule",     // Base classes cannot override consumer styles
      emphasis
    ].filter(Boolean).join(" ")}
    {...props}
  />
);
```
""" .

# CSS ClassName Concatenation Standard
:ClassNameConcatenation a cs:CodeStandard ;
    cs:name "react/component/classname-concatenation" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Class names must be constructed using an array and `.join(' ')`. This approach is more maintainable and less error-prone than direct string concatenation, as it simplifies adding, removing, and filtering classes." ;
    cs:dos """
(Do) Build the `className` string by joining an array of classes.
```tsx
const Rule = ({ className, emphasis, ...props }: RuleProps) => (
  <hr
    className={["ds rule", emphasis, className].filter(Boolean).join(" ")}
    {...props}
  />
);
```
""" ;
    cs:donts """
(Don't) Concatenate `className` strings directly using template literals or the `+` operator.
```tsx
const Rule = ({ className, emphasis, ...props }: RuleProps) => (
  <hr
    className={`${className} ds rule ${emphasis}`} // Bad: Hard to maintain
    {...props}
  />
);
```
""" .

# Component Props Structure Standard
:ComponentPropsStructure a cs:CodeStandard ;
    cs:name "react/component/props-structure" ;
    cs:hasCategory :ReactCategory ;
    cs:description """Component props should follow a consistent structure and consumption pattern:
- Props used explicitly in JSX should be destructured
- Remaining props should be spread to the root element
- Props should be grouped by purpose and usage""" ;
    cs:dos """# Proper props structure and consumption
```tsx
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  // Explicit props - will be used directly
  label: string;
  icon?: React.ReactNode;
  // Modifier props
  emphasis?: ModifierFamily<"emphasis">;
  // Additional type safety
  children?: never; // Button uses label prop instead
}

const Button = ({
  // Destructure props used explicitly in JSX
  label,
  icon,
  emphasis,
  className,
  // Spread remaining props to root element
  ...props
}: ButtonProps) => (
  <button
    className={["ds button", emphasis, className].filter(Boolean).join(" ")}
    {...props}  // HTML button props spread here
  >
    {icon}
    <span>{label}</span>
  </button>
);
```

This pattern provides:
- Clear prop usage intent
- Type safety for HTML attributes
- Predictable prop behavior""" ;
    cs:donts """# Problematic props handling
```tsx
// Don't mix explicit and spread props
const Button = (props: ButtonProps) => (
  <button
    className={props.className}
    onClick={props.onClick}  // Bad: Mixed with spread props
    {...props}  // May cause duplicate props
  >
    {props.label}
  </button>
);

// Don't destructure props that will be spread
const Button = ({
  label,
  className,
  onClick,  // Bad: Destructured but should be in ...props
  onFocus,  // Bad: Destructured but should be in ...props
  ...props
}: ButtonProps) => (
  <button
    className={className}
    onClick={onClick}
    onFocus={onFocus}
    {...props}
  >
    {label}
  </button>
);
```

These approaches:
- Can cause prop conflicts
- Make maintenance harder
- Reduce code clarity""" .

# Wrapper Component Props Standard
:WrapperComponentProps a cs:CodeStandard ;
    cs:name "react/component/wrapper-props" ;
    cs:hasCategory :ReactCategory ;
    cs:description """When a component's purpose is to wrap another component, it should:
- Accept all unscoped props for the wrapper element
- Use namespaced props for inner components
- Follow semantic naming for prop namespaces""" ;
    cs:dos """# Proper wrapper component structure
```tsx
interface ThumbnailSectionProps extends SectionProps {
  // Namespaced props for inner image
  imageProps: Omit<React.ImgHTMLAttributes<HTMLImageElement>, "alt"> & {
    alt: string; // Make alt required
  };
}

const ThumbnailSection = ({
  imageProps,  // Namespaced props for image
  className,
  ...props    // Unscoped props for Section
}: ThumbnailSectionProps) => (
  <Section className={["thumbnail-section", className].filter(Boolean).join(" ")} {...props}>
    <img {...imageProps} />  // Apply namespaced props
    {props.children}
  </Section>
);
```

This approach:
- Keeps prop scoping clear
- Maintains type safety
- Provides semantic prop grouping""" ;
    cs:donts """# Problematic wrapper patterns
```tsx
// Don't mix prop scopes
const ThumbnailSection = ({
  src,      // Bad: Unscoped image props
  alt,      // Bad: Unscoped image props
  width,    // Bad: Ambiguous - for image or section?
  ...props
}: ThumbnailSectionProps) => (
  <Section {...props}>
    <img src={src} alt={alt} width={width} />
  </Section>
);

// Don't use non-semantic prop names
const ThumbnailSection = ({
  innerProps,    // Bad: Not semantic
  wrapperProps,  // Bad: Not semantic
  ...props
}: ThumbnailSectionProps) => (
  <Section {...wrapperProps}>
    <img {...innerProps} />
  </Section>
);
```

These patterns:
- Create prop scope confusion
- Make component usage unclear
- Reduce code maintainability""" .

# HTML Element Props Standard
:HTMLElementProps a cs:CodeStandard ;
    cs:name "react/component/html-element-props" ;
    cs:hasCategory :ReactCategory ;
    cs:description """Components that render HTML elements should extend the appropriate React HTML element type:
- Use React's built-in HTML element interfaces
- Extend the interface that matches the root element
- Override prop types only when providing stronger constraints""" ;
    cs:dos """# Proper HTML element prop typing
```tsx
// Extend button element props
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  label: string;  // Add required prop
  emphasis?: ModifierFamily<"emphasis">;  // Add optional prop
  children?: never;  // Explicitly prevent children
}

// Extend input element props
interface TextFieldProps extends React.InputHTMLAttributes<HTMLInputElement> {
  // Override type to be more specific
  type?: "text" | "email" | "password";
}

// Extend div element props for container components
interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  emphasis?: ModifierFamily<"emphasis">;
}
```

This approach:
- Provides complete HTML attribute typing
- Maintains proper type constraints
- Ensures consistent prop behavior""" ;
    cs:donts """# Problematic HTML prop typing
```tsx
// Don't create props without HTML element types
interface ButtonProps {  // Bad: Missing HTML button props
  label: string;
  onClick?: () => void;  // Duplicating HTML props
  disabled?: boolean;    // Duplicating HTML props
}

// Don't use incorrect HTML element interface
interface CardProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  // Bad: Card renders a div but extends button props
}

// Don't type HTML props manually
interface TextFieldProps {
  value?: string;        // Bad: Manually typing what React provides
  onChange?: (e: any) => void;  // Bad: Incorrect event type
  [key: string]: any;    // Bad: Unsafe prop spreading
}
```

These approaches:
- Miss standard HTML attributes
- Provide incorrect type safety
- Create inconsistent behavior""" .

# Custom Hooks Standard
:CustomHooks a cs:CodeStandard ;
    cs:name "react/hooks/custom" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Custom hooks should be used when:
- Logic needs to be shared between components
- Component logic becomes complex
- State management needs to be abstracted
- Side effects need to be encapsulated" ;
    cs:dos """
(Do) Create a custom hook to share stateful logic between components.
```typescript
// useLocalStorage.ts
function useLocalStorage(key: string, initialValue: any) {
  // ... logic to sync state with localStorage
}
```

(Do) Organize hooks based on their scope: local hooks inside the component folder, and global hooks in a shared `hooks/` directory.
```
// Local hook for a single component
MyComponent/
  └── useMyComponentState.ts

// Global, shared hook
src/
  └── ui/
      └── hooks/
          └── useWindowFitment/
              ├── index.ts
              └── useWindowFitment.ts
```
""" ;
    cs:donts """
(Don't) Create a custom hook for simple, non-reusable state.
```tsx
// Bad: Unnecessary abstraction for a simple counter
const useCounter = () => {
  const [count, setCount] = useState(0);
  return { count, setCount };
};
```

(Don't) Mix multiple, unrelated concerns in a single hook.
```typescript
// Bad: This hook is doing too much (authentication, profile, settings)
const useUserData = () => {
  // ...
};
```
""" .

# Context Provider Structure Standard
:ContextProviderStructure a cs:CodeStandard ;
    cs:name "react/file-structure/context" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Context providers should be organized within the component folder that owns the context. The folder should contain `Context.tsx` for the context definition and `Provider.tsx` for the provider component." ;
    cs:dos """
(Do) Place context-related files directly within the owning component's folder.
```
MyComponent/
  ├── Context.tsx     // Defines the context with createContext()
  ├── Provider.tsx    // The component that provides the context value
  ├── MyComponent.tsx
  └── index.ts
```
""" ;
    cs:donts """
(Don't) Place context files in a separate `context/` subfolder, as it adds unnecessary nesting.
```
MyComponent/
  └── context/
      ├── Context.tsx
      └── Provider.tsx
```

(Don't) Place context files in a generic, top-level `contexts/` folder, as it obscures ownership.
```
src/
  └── contexts/
      └── MyComponentContext.ts // Bad: Should be inside MyComponent/
```
""" .

# DS Selector Class Standard
:ClassNameDSSelector a cs:CodeStandard ;
    cs:name "react/component/classname-ds-selector" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Every component must include a design system (ds) selector as the first class in its className list. This ensures consistent namespacing and styling across the design system." ;
    cs:dos """
(Do) Always include a ds selector as the first class in the className list:
```tsx
const Button = ({ className, ...props }: ButtonProps) => (
  <button
    className={["ds button", className].filter(Boolean).join(" ")}
    {...props}
  >
    {props.children}
  </button>
);
```

(Do) Use a specific ds selector for each component type:
```tsx
"ds card"
"ds input"
"ds modal"
```
""" ;
    cs:donts """
(Don't) Omit the ds selector from the className list:
```tsx
const Button = ({ className, ...props }: ButtonProps) => (
  <button
    className={[className].filter(Boolean).join(" ")}
    {...props}
  />
); // Bad: No ds selector present
```

(Don't) Place the ds selector after other classes:
```tsx
const Button = ({ className, ...props }: ButtonProps) => (
  <button
    className={[className, "ds button"].filter(Boolean).join(" ")}
    {...props}
  />
); // Bad: ds selector is not first
```
