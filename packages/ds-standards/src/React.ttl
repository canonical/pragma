@prefix cso: <http://pragma.canonical.com/codestandards#> .
@prefix cs: <http://pragma.canonical.com/codestandards#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# React Category
cs:ReactCategory a cso:Category ;
    rdfs:label "React"@en ;
    rdfs:comment "Standards specific to React development"@en ;
    cso:slug "react" .

# Component Folder Structure Standard
cs:ComponentFolderStructure a cso:CodeStandard ;
    cso:name "react/component/folder-structure" ;
    cso:hasCategory cso:ReactCategory ;
    cso:description "Each component must reside in its own folder, which contains all related files: component implementation, tests, type definitions, and optionally stories and styles. Some components may be styleless or may not have stories; styles.css and MyComponent.stories.tsx are optional." ;
    cso:dos """
(Do) Place all files related to a single component within the same component folder. `styles.css` and `MyComponent.stories.tsx` are optional.
```
MyComponent/
  ├── MyComponent.tsx
  ├── MyComponent.tests.tsx
  ├── index.ts
  ├── types.ts
  ├── styles.css         # optional
  ├── MyComponent.stories.tsx  # optional
```
""" ;
    cso:donts """
(Don't) Place multiple components in the same folder.
```
MyComponent/
  ├── MyComponent.tsx
  ├── AnotherComponent.tsx   # Bad: Should be in its own folder
  └── index.ts
```

(Don't) Omit the `index.ts` file for barrel exports.
```
MyComponent/
  ├── MyComponent.tsx
  # Bad: Missing index.ts
```
""" .

# Component Folder Naming Standard
cs:ComponentFolderNaming a cso:CodeStandard ;
    cso:name "react/component/folder-naming" ;
    cso:hasCategory :ReactCategory ;
    cso:description "Component folders must be named using PascalCase (e.g., `Button`, `Tooltip`)." ;
    cso:dos """
(Do) Name the component folder using PascalCase.
```
MyComponent/
Tooltip/
Button/
```
""" ;
    cso:donts """
(Don't) Use kebab-case or snake_case for component folder names.
```
my-component/
tooltip_folder/
```
""" .

# Component File Naming Standard
cs:ComponentFileNaming a cso:CodeStandard ;
    cso:name "react/component/file-naming" ;
    cso:hasCategory :ReactCategory ;
    cso:description "Files within a component's folder must be named after the component, using the format `ComponentName.filetype.tsx`. For example, `MyComponent.stories.tsx`." ;
    cso:dos """
(Do) Name files using the component's name as a prefix.
```
MyComponent/
  ├── MyComponent.tsx
  ├── MyComponent.stories.tsx
  ├── MyComponent.tests.tsx
```
""" ;
    cso:donts """
(Don't) Use generic or inconsistent file names.
```
MyComponent/
  ├── main.tsx           # Bad: Not named after the component
  ├── story.tsx          # Bad: Not named after the component
  ├── test.tsx           # Bad: Not named after the component
```
""" .

# Component Props Typing Standard
cs:ComponentPropsTyping a cso:CodeStandard ;
    cso:name "react/component/props-typing" ;
    cso:hasCategory :ReactCategory ;
    cso:description "Component props must be explicitly typed using TypeScript interfaces." ;
    cso:dos """
(Do) Define an interface for the component's props.
```typescript
interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
}

const Button = ({ label, onClick, variant = 'primary' }: ButtonProps) => {
  // ...
};
```
""" ;
    cso:donts """
(Don't) Use `any` for prop types.
```typescript
const Button = (props: any) => {
  // ...
};
```

(Don't) Destructure props without providing a type.
```typescript
const Button = ({ label, onClick }) => {
  // ...
};
```
""" .

# Component Props Naming Standard
cs:ComponentPropsNaming a cso:CodeStandard ;
    cso:name "react/component/props-naming" ;
    cso:hasCategory :ReactCategory ;
    cso:description "Prop names must be semantic and clearly describe their purpose." ;
    cso:dos """
(Do) Use descriptive names for props.
```typescript
interface ButtonProps {
  label: string;
  onClick: () => void;
}
```
""" ;
    cso:donts """
(Don't) Use non-semantic or unclear prop names.
```typescript
interface ButtonProps {
  a: string;      // Bad: Not descriptive
  b: () => void;  // Bad: Not descriptive
}
```
""" .

# Component Naming Standard
cs:ComponentNaming a cso:CodeStandard ;
    cso:name "react/component/naming" ;
    cso:hasCategory :ReactCategory ;
    cso:description "Components must use PascalCase naming and be descriptive of their purpose." ;
    cso:dos """
(Do) Use PascalCase and descriptive names for components:
UserProfile
NavigationBar
SearchResultList
""" ;
    cso:donts """
(Don't) Use non-PascalCase or unclear names:
userProfile
navigation_bar
searchresultlist
""" .

# Hook Naming Standard
cs:HookNaming a cso:CodeStandard ;
    cso:name "react/hook/naming" ;
    cso:hasCategory :ReactCategory ;
    cso:description "The hook name must start with 'use' and clearly describe its purpose." ;
    cso:dos """
(Do) Name custom hooks so the hook name starts with 'use' and is descriptive:
```typescript
useWindowSize()
useAuthentication()
useFormValidation()
```
""" ;
    cso:donts """
(Don't) Name hooks without the 'use' prefix at the start of the hook name:
```typescript
windowSize()
getAuth()
formValidation()
```
""" .

# Context Shortcut Hook Naming Standard
cs:ContextShortcutHookNaming a cso:CodeStandard ;
    cso:name "react/hook/naming/context-shortcuts" ;
    cso:hasCategory :ReactCategory ;
    cso:description "Context shortcut hooks must use the pattern useContextName, where the hook name starts with 'use' followed by the context name in PascalCase." ;
    cso:dos """
(Do) Name context shortcut hooks so the hook name starts with 'use' and follows the pattern useContextName:
```typescript
useApplicationSettings()
useUserPreferences()
useThemeContext()
```
""" ;
    cso:donts """

(Don't) Use unclear or generic names for context shortcut hooks:
```typescript
settingsContext()
preferences()
theme()
```
""" .

# Component Dependencies Standard
cs:ComponentDependencies a cso:CodeStandard ;
    cso:name "react/component/dependencies" ;
    cso:hasCategory :ReactCategory ;
    cso:description """Component dependencies must follow a strict unidirectional flow:
- Subcomponents must be in a `common/` folder within the parent component's directory
- Dependencies can flow downwards (parent to subcomponent) or sideways (between siblings)
- Dependencies must not flow upwards (subcomponent to parent)""" ;
    cso:dos """
(Do) Place subcomponents in a `common/` folder inside the parent component directory.
```
Card/
  ├── Card.tsx
  ├── common/
  │   ├── Header/
  │   │   └── Header.tsx
  │   ├── Footer/
  │   │   └── Footer.tsx
  │   └── utils/
  │       └── helpers.ts
  └── index.ts
```

(Do) Allow subcomponents to depend on siblings or shared utilities within the same component scope.
```typescript
// Header.tsx can import from utils/
import { helper } from '../utils/helpers';

// Footer.tsx can import from Header.tsx
import Header from '../Header';
```
""" ;
    cso:donts """
(Don't) Create dependencies that flow upwards from a subcomponent to its parent.
```typescript
// Bad: Header.tsx in Card/common/ should not import from Card.tsx
import Card from '../../Card';
```

(Don't) Allow external components to depend on the internal structure of another component.
```typescript
// Bad: AnotherComponent should not import from Card's internal common folder
import Header from '../Card/common/Header';
```
""" .

# Subcomponents Export and Consumption API Standard
cs:SubcomponentsExportAPI a cso:CodeStandard ;
    cso:name "react/component/subcomponents/export-api" ;
    cso:hasCategory :ReactCategory ;
    cso:description """Public subcomponents must be:
- Exported by attaching to parent component using dot notation
- Named semantically
- Kept to a single level of nesting
Private subcomponents must remain internal.""" ;
    cso:dos """
(Do) Export public subcomponents by attaching them to the parent component using dot notation:
```typescript
const Item = (props: ItemProps) => { /* ... */ };
const Accordion = (props: AccordionProps) => { /* ... */ };
Accordion.Item = Item;
export default Accordion;
```

(Do) Use semantic, self-descriptive names for subcomponents:
```typescript
Accordion.Item
Card.Header
Card.Footer
```

(Do) Keep subcomponent nesting to a single level:
```typescript
<Card>
  <Card.Header />
  <Card.Footer />
</Card>
```

(Do) Keep private subcomponents internal and do not export them:
```typescript
// Only export subcomponents intended for public use
// Private subcomponents remain unexported
```
""" ;
    cso:donts """
(Don't) Repeat the parent component name in subcomponent names:
```typescript
Card.CardHeader = Header; // Bad: Redundant 'Card' prefix
```

(Don't) Map a subcomponent to a different name (renaming):
```typescript
Card.Top = Header; // Bad: Mapping 'Header' to 'Top' is not allowed
```

(Don't) Use non-semantic or unclear subcomponent names:
```typescript
Card.Part1 = Section; // Bad: 'Part1' is not descriptive
```

(Don't) Create deeply nested subcomponent hierarchies:
```typescript
<Card>
  <Card.Section>
    <Card.Section.Header>
      <Card.Section.Header.Title /> // Bad: Too deep
    </Card.Section.Header>
  </Card.Section>
</Card>
```


(Don't) Export private subcomponents that are not intended for public use.
```typescript
// Bad: Exporting internal-only subcomponents
export { InternalHelper };
```
""" .

# CSS ClassName Ordering Standard
cs:ClassNameOrdering a cso:CodeStandard ;
    cso:name "react/component/classname-ordering" ;
    cso:hasCategory :ReactCategory ;
    cso:description "The `className` prop must be the last class applied in a component's class list." ;
    cso:dos """
(Do) Apply the `className` prop at the end of the class list to ensure correct style overrides.
```tsx
const Rule = ({ className, emphasis, ...props }: RuleProps) => (
  <hr
    className={[
      "ds rule",     // Base component classes
      emphasis,      // Modifier classes
      className      // Consumer classes (last)
    ].filter(Boolean).join(" ")}
    {...props}
  />
);
```
""" ;
    cso:donts """
(Don't) Place the `className` prop before other classes in the list.
```tsx
const Rule = ({ className, emphasis, ...props }: RuleProps) => (
  <hr
    className={[
      className,     // Bad: Consumer classes appear first
      "ds rule",     // Base classes cannot override consumer styles
      emphasis
    ].filter(Boolean).join(" ")}
    {...props}
  />
);
```
""" .

# CSS ClassName Concatenation Standard
cs:ClassNameConcatenation a cso:CodeStandard ;
    cso:name "react/component/classname-concatenation" ;
    cso:hasCategory :ReactCategory ;
    cso:description "Class names must be constructed using an array and `.join(' ')`." ;
    cso:dos """
(Do) Build the `className` string by joining an array of classes.
```tsx
const Rule = ({ className, emphasis, ...props }: RuleProps) => (
  <hr
    className={["ds rule", emphasis, className].filter(Boolean).join(" ")}
    {...props}
  />
);
```
""" ;
    cso:donts """
(Don't) Concatenate `className` strings directly using template literals or the `+` operator.
```tsx
const Rule = ({ className, emphasis, ...props }: RuleProps) => (
  <hr
    className={`${className} ds rule ${emphasis}`} // Bad: Hard to maintain
    {...props}
  />
);
```
""" .

# Component Props Structure Standard
cs:ComponentPropsStructure a cso:CodeStandard ;
    cso:name "react/component/props-structure" ;
    cso:hasCategory :ReactCategory ;
    cso:description """Component props must:
- Be destructured when used explicitly in JSX
- Be spread to the root element when unused
- Be grouped by purpose and usage""" ;
    cso:dos """# Proper props structure and consumption
```tsx
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  // Explicit props - will be used directly
  label: string;
  icon?: React.ReactNode;
  // Modifier props
  emphasis?: ModifierFamily<"emphasis">;
  // Additional type safety
  children?: never; // Button uses label prop instead
}

const Button = ({
  // Destructure props used explicitly in JSX
  label,
  icon,
  emphasis,
  className,
  // Spread remaining props to root element
  ...props
}: ButtonProps) => (
  <button
    className={["ds button", emphasis, className].filter(Boolean).join(" ")}
    {...props}  // HTML button props spread here
  >
    {icon}
    <span>{label}</span>
  </button>
);
```
""" ;
    cso:donts """# Problematic props handling
```tsx
// Don't mix explicit and spread props
const Button = (props: ButtonProps) => (
  <button
    className={props.className}
    onClick={props.onClick}  // Bad: Mixed with spread props
    {...props}  // May cause duplicate props
  >
    {props.label}
  </button>
);

// Don't destructure props that will be spread
const Button = ({
  label,
  className,
  onClick,  // Bad: Destructured but should be in ...props
  onFocus,  // Bad: Destructured but should be in ...props
  ...props
}: ButtonProps) => (
  <button
    className={className}
    onClick={onClick}
    onFocus={onFocus}
    {...props}
  >
    {label}
  </button>
);
```

These approaches:
- Can cause prop conflicts
- Make maintenance harder
- Reduce code clarity""" .

# Wrapper Component Props Standard
cs:WrapperComponentProps a cso:CodeStandard ;
    cso:name "react/component/wrapper-props" ;
    cso:hasCategory :ReactCategory ;
    cso:description """Wrapper components must:
- Accept all unscoped props for the wrapper element
- Use namespaced props for inner components
- Follow semantic naming for prop namespaces""" ;
    cso:dos """# Proper wrapper component structure
```tsx
interface ThumbnailSectionProps extends SectionProps {
  // Namespaced props for inner image
  imageProps: Omit<React.ImgHTMLAttributes<HTMLImageElement>, "alt"> & {
    alt: string; // Make alt required
  };
}

const ThumbnailSection = ({
  imageProps,  // Namespaced props for image
  className,
  ...props    // Unscoped props for Section
}: ThumbnailSectionProps) => (
  <Section className={["thumbnail-section", className].filter(Boolean).join(" ")} {...props}>
    <img {...imageProps} />  // Apply namespaced props
    {props.children}
  </Section>
);
```
""" ;
    cso:donts """# Problematic wrapper patterns
```tsx
// Don't mix prop scopes
const ThumbnailSection = ({
  src,      // Bad: Unscoped image props
  alt,      // Bad: Unscoped image props
  width,    // Bad: Ambiguous - for image or section?
  ...props
}: ThumbnailSectionProps) => (
  <Section {...props}>
    <img src={src} alt={alt} width={width} />
  </Section>
);

// Don't use non-semantic prop names
const ThumbnailSection = ({
  innerProps,    // Bad: Not semantic
  wrapperProps,  // Bad: Not semantic
  ...props
}: ThumbnailSectionProps) => (
  <Section {...wrapperProps}>
    <img {...innerProps} />
  </Section>
);
```

These patterns:
- Create prop scope confusion
- Make component usage unclear
- Reduce code maintainability""" .

# HTML Element Props Standard
cs:HTMLElementProps a cso:CodeStandard ;
    cso:name "react/component/html-element-props" ;
    cso:hasCategory :ReactCategory ;
    cso:description """Components that render HTML elements must:
- Use React's built-in HTML element interfaces
- Extend the interface that matches the root element
- Override prop types only when providing stronger constraints""" ;
    cso:dos """# Proper HTML element prop typing
```tsx
// Extend button element props
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  label: string;  // Add required prop
  emphasis?: ModifierFamily<"emphasis">;  // Add optional prop
  children?: never;  // Explicitly prevent children
}

// Extend input element props
interface TextFieldProps extends React.InputHTMLAttributes<HTMLInputElement> {
  // Override type to be more specific
  type?: "text" | "email" | "password";
}

// Extend div element props for container components
interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  emphasis?: ModifierFamily<"emphasis">;
}
```

This approach:
- Provides complete HTML attribute typing
- Maintains proper type constraints
- Ensures consistent prop behavior""" ;
    cso:donts """# Problematic HTML prop typing
```tsx
// Don't create props without HTML element types
interface ButtonProps {  // Bad: Missing HTML button props
  label: string;
  onClick?: () => void;  // Duplicating HTML props
  disabled?: boolean;    // Duplicating HTML props
}

// Don't use incorrect HTML element interface
interface CardProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  // Bad: Card renders a div but extends button props
}

// Don't type HTML props manually
interface TextFieldProps {
  value?: string;        // Bad: Manually typing what React provides
  onChange?: (e: any) => void;  // Bad: Incorrect event type
  [key: string]: any;    // Bad: Unsafe prop spreading
}
```

These approaches:
- Miss standard HTML attributes
- Provide incorrect type safety
- Create inconsistent behavior""" .

# Custom Hooks Standard
cs:CustomHooks a cso:CodeStandard ;
    cso:name "react/hooks/custom" ;
    cso:hasCategory :ReactCategory ;
    cso:description "Custom hooks must be used when:
- Logic needs to be shared between components
- Component logic becomes complex
- State management needs to be abstracted
- Side effects need to be encapsulated" ;
    cso:dos """
(Do) Create a custom hook to share stateful logic between components.
```typescript
// useLocalStorage.ts
function useLocalStorage(key: string, initialValue: any) {
  // ... logic to sync state with localStorage
}
```

(Do) Organize hooks based on their scope: local hooks inside the component folder, and global hooks in a shared `hooks/` directory.
```
// Local hook for a single component
MyComponent/
  └── useMyComponentState.ts

// Global, shared hook
src/
  └── ui/
      └── hooks/
          └── useWindowFitment/
              ├── index.ts
              └── useWindowFitment.ts
```
""" ;
    cso:donts """
(Don't) Create a custom hook for simple, non-reusable state.
```tsx
// Bad: Unnecessary abstraction for a simple counter
const useCounter = () => {
  const [count, setCount] = useState(0);
  return { count, setCount };
};
```

(Don't) Mix multiple, unrelated concerns in a single hook.
```typescript
// Bad: This hook is doing too much (authentication, profile, settings)
const useUserData = () => {
  // ...
};
```
""" .

# Context Provider Structure Standard
cs:ContextProviderStructure a cso:CodeStandard ;
    cso:name "react/file-structure/context" ;
    cso:hasCategory :ReactCategory ;
    cso:description "Context providers must be organized within the component folder that owns the context, containing:
- `Context.tsx` for context definition
- `Provider.tsx` for provider component" ;
    cso:dos """
(Do) Place context-related files directly within the owning component's folder.
```
MyComponent/
  ├── Context.tsx     // Defines the context with createContext()
  ├── Provider.tsx    // The component that provides the context value
  ├── MyComponent.tsx
  └── index.ts
```
""" ;
    cso:donts """
(Don't) Place context files in a separate `context/` subfolder, as it adds unnecessary nesting.
```
MyComponent/
  └── context/
      ├── Context.tsx
      └── Provider.tsx
```

(Don't) Place context files in a generic, top-level `contexts/` folder, as it obscures ownership.
```
src/
  └── contexts/
      └── MyComponentContext.ts // Bad: Should be inside MyComponent/
```
""" .

# DS Selector Class Standard
cs:ClassNameDSSelector a cso:CodeStandard ;
    cso:name "react/component/classname-ds-selector" ;
    cso:hasCategory :ReactCategory ;
    cso:description "Every component must include a design system (ds) selector as the first class in its className list." ;
    cso:dos """
(Do) Always include a ds selector as the first class in the className list:
```tsx
const Button = ({ className, ...props }: ButtonProps) => (
  <button
    className={["ds button", className].filter(Boolean).join(" ")}
    {...props}
  >
    {props.children}
  </button>
);
```

(Do) Use a specific ds selector for each component type:
```tsx
"ds card"
"ds input"
"ds modal"
```
""" ;
    cso:donts """
(Don't) Omit the ds selector from the className list:
```tsx
const Button = ({ className, ...props }: ButtonProps) => (
  <button
    className={[className].filter(Boolean).join(" ")}
    {...props}
  />
); // Bad: No ds selector present
```

(Don't) Place the ds selector after other classes:
```tsx
const Button = ({ className, ...props }: ButtonProps) => (
  <button
    className={[className, "ds button"].filter(Boolean).join(" ")}
    {...props}
  />
); // Bad: ds selector is not first
```
