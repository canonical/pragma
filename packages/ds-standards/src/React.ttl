@prefix : <http://example.org/codestandards#> .
@prefix cs: <http://example.org/codestandards#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# React Category
:ReactCategory a cs:Category ;
    rdfs:label "React"@en ;
    rdfs:comment "Standards specific to React development"@en .

# Component Structure Standard
:ComponentStructure a cs:CodeStandard ;
    cs:name "react/component/folder-structure" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Each component must reside in its own PascalCase-named folder (e.g., Button, Tooltip). The folder should contain the following files with these exact names: ComponentName.tsx (main implementation), ComponentName.stories.tsx (Storybook stories), ComponentName.tests.tsx (unit/integration tests), index.ts (public API), styles.css (component styles, if applicable), and types.ts (TypeScript type definitions for props)." ;
    cs:dos """
(Do) Create a component folder with the following file names:
```
MyComponent/
  ├── MyComponent.tsx            # Main component implementation
  ├── MyComponent.stories.tsx    # Storybook stories
  ├── MyComponent.tests.tsx      # Unit/integration tests
  ├── index.ts                   # Public API
  ├── styles.css                 # Component styles (if applicable)
  └── types.ts                   # TypeScript type definitions for props
```
""" ;
    cs:donts """
(Don't) Use inconsistent or missing file names in the component folder:
```
MyComponent/
  ├── main.tsx           # Bad: Not named after component
  ├── story.tsx          # Bad: Not named after component
  ├── test.tsx           # Bad: Not named after component
  ├── index.js           # Bad: Wrong extension
  └── types.js           # Bad: Wrong extension
```

(Don't) Place multiple components in one folder:
```
MyComponent/
  ├── MyComponent.tsx
  ├── AnotherComponent.tsx   # Bad: Multiple components in one folder
  ├── index.ts
```

(Don't) Omit index.ts for exports:
```
MyComponent/
  ├── MyComponent.tsx
  ├── MyComponent.stories.tsx
  ├── MyComponent.tests.tsx
  ├── styles.css
  └── types.ts
  # Bad: Missing index.ts
```
""" .

# Component Props Standard
:ComponentProps a cs:CodeStandard ;
    cs:name "react/component/props" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Props should be explicitly typed using TypeScript interfaces and follow consistent naming patterns." ;
    cs:dos """
(Do) Explicitly type props using TypeScript interfaces:
```typescript
interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
}

const Button = ({ label, onClick, variant = 'primary' }: ButtonProps) => {
  // ...
};
```
""" ;
    cs:donts """
(Don't) Use `any` for prop types:
```typescript
const Button = (props: any) => {
  // ...
};
```

(Don't) Destructure props in function parameters without type:
```typescript
const Button = ({ label, onClick }) => {
  // ...
};
```

(Don't) Use non-semantic prop names:
```typescript
interface ButtonProps {
  a: string;      // Bad: Not descriptive
  b: () => void;  // Bad: Not descriptive
}
```
""" .

# Component Naming Standard
:ComponentNaming a cs:CodeStandard ;
    cs:name "react/component/naming" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Components should use PascalCase naming and be descriptive of their purpose." ;
    cs:dos """
(Do) Use PascalCase and descriptive names for components:
UserProfile
NavigationBar
SearchResultList
""" ;
    cs:donts """
(Don't) Use non-PascalCase or unclear names:
userProfile
navigation_bar
searchresultlist
""" .

# Hook Naming Standard
:HookNaming a cs:CodeStandard ;
    cs:name "react/hook/naming" ;
    cs:hasCategory :ReactCategory ;
    cs:description "The hook name must start with 'use' and clearly describe its purpose." ;
    cs:dos """
(Do) Name custom hooks so the hook name starts with 'use' and is descriptive:
```typescript
useWindowSize()
useAuthentication()
useFormValidation()
```
""" ;
    cs:donts """
(Don't) Name hooks without the 'use' prefix at the start of the hook name:
```typescript
windowSize()
getAuth()
formValidation()
```
""" .

# Context Shortcut Hook Naming Standard
:ContextShortcutHookNaming a cs:CodeStandard ;
    cs:name "react/hook/naming/context-shortcuts" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Context shortcut hooks should use the pattern useContextName, where the hook name starts with 'use' followed by the context name in PascalCase (e.g., useApplicationSettings)." ;
    cs:dos """
(Do) Name context shortcut hooks so the hook name starts with 'use' and follows the pattern useContextName:
```typescript
useApplicationSettings()
useUserPreferences()
useThemeContext()
```
""" ;
    cs:donts """

(Don't) Use unclear or generic names for context shortcut hooks:
```typescript
settingsContext()
preferences()
theme()
```
""" .

# Subcomponents Folder and Dependency Structure Standard
:SubcomponentsFolderStructure a cs:CodeStandard ;
    cs:name "react/component/subcomponents/folder-structure" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Subcomponents should be organized in a common/ folder within the parent component directory. Dependencies should be directional: parent can depend on subcomponents, subcomponents can depend on siblings or shared utils, but not on the parent." ;
    cs:dos """
(Do) Place subcomponents in a common/ folder inside the parent component directory:
```
Card/
  ├── Card.tsx
  ├── common/
  │   ├── Header/
  │   │   └── Header.tsx
  │   ├── Footer/
  │   │   └── Footer.tsx
  │   └── utils/
  │       └── helpers.ts
  └── index.ts
```

(Do) Allow subcomponents to depend on siblings or shared utils:
```
// Header.tsx can import from utils/
import { helper } from '../utils/helpers';
```
""" ;
    cs:donts """
(Don't) Place subcomponents outside the common/ folder:
```
Card/
  ├── Card.tsx
  ├── Header/
  │   └── Header.tsx    // Bad: Not in common/
```

(Don't) Create circular dependencies (subcomponents should not import from parent):
```
// Bad: Header.tsx importing from Card.tsx
import Card from '../Card';
```
""" ;

# Subcomponents Export and Consumption API Standard
:SubcomponentsExportAPI a cs:CodeStandard ;
    cs:name "react/component/subcomponents/export-api" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Public subcomponents should be exported by attaching them to the parent component using dot notation and semantic names. Private subcomponents remain internal. Consumers should use dot notation to access public subcomponents, with flat, semantic hierarchy." ;
    cs:dos """
(Do) Export public subcomponents by attaching them to the parent component using dot notation:
```typescript
const Item = (props: ItemProps) => { /* ... */ };
const Accordion = (props: AccordionProps) => { /* ... */ };
Accordion.Item = Item;
export default Accordion;
```

(Do) Use semantic, self-descriptive names for subcomponents:
```typescript
Accordion.Item
Card.Header
Card.Footer
```

(Do) Keep subcomponent nesting to a single level:
```typescript
<Card>
  <Card.Header />
  <Card.Footer />
</Card>
```

(Do) Keep private subcomponents internal and do not export them:
```typescript
// Only export subcomponents intended for public use
// Private subcomponents remain unexported
```
""" ;
    cs:donts """
(Don't) Repeat the parent component name in subcomponent names:
```typescript
Card.CardHeader = Header; // Bad: Redundant 'Card' prefix
```

(Don't) Map a subcomponent to a different name (renaming):
```typescript
Card.Top = Header; // Bad: Mapping 'Header' to 'Top' is not allowed
```

(Don't) Use non-semantic or unclear subcomponent names:
```typescript
Card.Part1 = Section; // Bad: 'Part1' is not descriptive
```

(Don't) Create deeply nested subcomponent hierarchies:
```typescript
<Card>
  <Card.Section>
    <Card.Section.Header>
      <Card.Section.Header.Title /> // Bad: Too deep
    </Card.Section.Header>
  </Card.Section>
</Card>
```


(Don't) Export private subcomponents:
```typescript
// Bad: Exporting internal-only subcomponents
export { InternalHelper };
```
""" .

# CSS Class Ordering Standard
:ClassNameOrdering a cs:CodeStandard ;
    cs:name "react/component/classname-ordering" ;
    cs:hasCategory :ReactCategory ;
    cs:description """The className prop should be the last-applied CSS class in a component's class list to ensure proper CSS specificity and override behavior. This allows consumers to reliably override component styles when needed.""" ;
    cs:dos """# Proper className ordering
```tsx
// Component applies classes in correct order: base classes first, className last
const Rule = ({ className, emphasis, ...props }: RuleProps) => (
  <hr
    className={[
      "ds rule",     // Base component classes
      emphasis,      // Modifier classes
      className      // Consumer classes (last)
    ].filter(Boolean).join(" ")}
    {...props}
  />
);
```

This pattern ensures:
- Base styles establish default appearance
- Modifier classes apply their changes
- Consumer classes have highest specificity for overrides""" ;
    cs:donts """# Incorrect className ordering
```tsx
// Don't put className before other classes
const Rule = ({ className, emphasis, ...props }: RuleProps) => (
  <hr
    className={[
      className,     // Bad: Consumer classes first
      "ds rule",     // Base classes can't override consumer styles
      emphasis       // Modifier might not work as expected
    ].filter(Boolean).join(" ")}
    {...props}
  />
);
```

These approaches:
- Make style overrides unpredictable
- Can break component styling
- Make maintenance more difficult""" .

# ClassName Concatenation Standard
:ClassNameConcatenation a cs:CodeStandard ;
    cs:name "react/component/classname-concatenation" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Class names should be constructed using arrays and .join(' ') for maintainability, filtering, and proper ordering. Avoid direct string concatenation for className." ;
    cs:dos """
(Do) Build className using arrays and .join(' '):
```tsx
const Rule = ({ className, emphasis, ...props }: RuleProps) => (
  <hr
    className={["ds rule", emphasis, className].filter(Boolean).join(" ")}
    {...props}
  />
);
```
""" ;
    cs:donts """
(Don't) Concatenate className strings directly:
```tsx
const Rule = ({ className, emphasis, ...props }: RuleProps) => (
  <hr
    className={`${className} ds rule ${emphasis}`}
    {...props}
  />
); // Bad: Hard to maintain, filter, and order
```
""" .

# Component Props Structure Standard
:ComponentPropsStructure a cs:CodeStandard ;
    cs:name "react/component/props-structure" ;
    cs:hasCategory :ReactCategory ;
    cs:description """Component props should follow a consistent structure and consumption pattern:
- Props used explicitly in JSX should be destructured
- Remaining props should be spread to the root element
- Props should be grouped by purpose and usage""" ;
    cs:dos """# Proper props structure and consumption
```tsx
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  // Explicit props - will be used directly
  label: string;
  icon?: React.ReactNode;
  // Modifier props
  emphasis?: ModifierFamily<"emphasis">;
  // Additional type safety
  children?: never; // Button uses label prop instead
}

const Button = ({
  // Destructure props used explicitly in JSX
  label,
  icon,
  emphasis,
  className,
  // Spread remaining props to root element
  ...props
}: ButtonProps) => (
  <button
    className={["ds button", emphasis, className].filter(Boolean).join(" ")}
    {...props}  // HTML button props spread here
  >
    {icon}
    <span>{label}</span>
  </button>
);
```

This pattern provides:
- Clear prop usage intent
- Type safety for HTML attributes
- Predictable prop behavior""" ;
    cs:donts """# Problematic props handling
```tsx
// Don't mix explicit and spread props
const Button = (props: ButtonProps) => (
  <button
    className={props.className}
    onClick={props.onClick}  // Bad: Mixed with spread props
    {...props}  // May cause duplicate props
  >
    {props.label}
  </button>
);

// Don't destructure props that will be spread
const Button = ({
  label,
  className,
  onClick,  // Bad: Destructured but should be in ...props
  onFocus,  // Bad: Destructured but should be in ...props
  ...props
}: ButtonProps) => (
  <button
    className={className}
    onClick={onClick}
    onFocus={onFocus}
    {...props}
  >
    {label}
  </button>
);
```

These approaches:
- Can cause prop conflicts
- Make maintenance harder
- Reduce code clarity""" .

# Wrapper Component Props Standard
:WrapperComponentProps a cs:CodeStandard ;
    cs:name "react/component/wrapper-props" ;
    cs:hasCategory :ReactCategory ;
    cs:description """When a component's purpose is to wrap another component, it should:
- Accept all unscoped props for the wrapper element
- Use namespaced props for inner components
- Follow semantic naming for prop namespaces""" ;
    cs:dos """# Proper wrapper component structure
```tsx
interface ThumbnailSectionProps extends SectionProps {
  // Namespaced props for inner image
  imageProps: Omit<React.ImgHTMLAttributes<HTMLImageElement>, "alt"> & {
    alt: string; // Make alt required
  };
}

const ThumbnailSection = ({
  imageProps,  // Namespaced props for image
  className,
  ...props    // Unscoped props for Section
}: ThumbnailSectionProps) => (
  <Section className={["thumbnail-section", className].filter(Boolean).join(" ")} {...props}>
    <img {...imageProps} />  // Apply namespaced props
    {props.children}
  </Section>
);
```

This approach:
- Keeps prop scoping clear
- Maintains type safety
- Provides semantic prop grouping""" ;
    cs:donts """# Problematic wrapper patterns
```tsx
// Don't mix prop scopes
const ThumbnailSection = ({
  src,      // Bad: Unscoped image props
  alt,      // Bad: Unscoped image props
  width,    // Bad: Ambiguous - for image or section?
  ...props
}: ThumbnailSectionProps) => (
  <Section {...props}>
    <img src={src} alt={alt} width={width} />
  </Section>
);

// Don't use non-semantic prop names
const ThumbnailSection = ({
  innerProps,    // Bad: Not semantic
  wrapperProps,  // Bad: Not semantic
  ...props
}: ThumbnailSectionProps) => (
  <Section {...wrapperProps}>
    <img {...innerProps} />
  </Section>
);
```

These patterns:
- Create prop scope confusion
- Make component usage unclear
- Reduce code maintainability""" .

# HTML Element Props Standard
:HTMLElementProps a cs:CodeStandard ;
    cs:name "react/component/html-element-props" ;
    cs:hasCategory :ReactCategory ;
    cs:description """Components that render HTML elements should extend the appropriate React HTML element type:
- Use React's built-in HTML element interfaces
- Extend the interface that matches the root element
- Override prop types only when providing stronger constraints""" ;
    cs:dos """# Proper HTML element prop typing
```tsx
// Extend button element props
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  label: string;  // Add required prop
  emphasis?: ModifierFamily<"emphasis">;  // Add optional prop
  children?: never;  // Explicitly prevent children
}

// Extend input element props
interface TextFieldProps extends React.InputHTMLAttributes<HTMLInputElement> {
  // Override type to be more specific
  type?: "text" | "email" | "password";
}

// Extend div element props for container components
interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  emphasis?: ModifierFamily<"emphasis">;
}
```

This approach:
- Provides complete HTML attribute typing
- Maintains proper type constraints
- Ensures consistent prop behavior""" ;
    cs:donts """# Problematic HTML prop typing
```tsx
// Don't create props without HTML element types
interface ButtonProps {  // Bad: Missing HTML button props
  label: string;
  onClick?: () => void;  // Duplicating HTML props
  disabled?: boolean;    // Duplicating HTML props
}

// Don't use incorrect HTML element interface
interface CardProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  // Bad: Card renders a div but extends button props
}

// Don't type HTML props manually
interface TextFieldProps {
  value?: string;        // Bad: Manually typing what React provides
  onChange?: (e: any) => void;  // Bad: Incorrect event type
  [key: string]: any;    // Bad: Unsafe prop spreading
}
```

These approaches:
- Miss standard HTML attributes
- Provide incorrect type safety
- Create inconsistent behavior""" .

# Component Dependencies Standard
:ComponentDependencies a cs:CodeStandard ;
    cs:name "react/component/dependencies" ;
    cs:hasCategory :ReactCategory ;
    cs:description """Component dependencies and common folder relationships should follow a strict directional pattern:
- Dependencies can go down into child components
- Dependencies can go sideways to sibling components
- Dependencies cannot go up to parent components
- Common folder contains shared code for the component""" ;
    cs:dos """# Proper dependency structure
```
Card/
  ├── Card.tsx              # Can import from common/
  ├── types.ts              # Can import from common/
  ├── styles.css
  ├── common/               # Shared code for Card
  │   ├── Header/          # Subcomponent
  │   │   ├── Header.tsx   # Can import from utils/
  │   │   └── types.ts
  │   ├── Footer/          # Sibling can import from Header/
  │   │   ├── Footer.tsx
  │   │   └── types.ts
  │   └── utils/           # Shared utilities
  │       └── helpers.ts
  └── index.ts
```

This structure allows:
- Card.tsx to import from common/
- Header to import from utils/
- Footer to import from Header/ (sideways)
- Shared code in common/ folder""" ;
    cs:donts """# Problematic dependency patterns
```
Card/
  ├── Card.tsx
  ├── common/
  │   └── Header/
  │       └── Header.tsx    # Don't import from Card.tsx
  └── Footer/
      └── Footer.tsx        # Don't import from ../Card.tsx

components/
  ├── Card/
  │   └── Card.tsx         # Don't import from ../Header
  └── Header/              # Don't let other components
      └── Header.tsx       # depend on internal structure
```

These patterns create:
- Circular dependencies
- Tight coupling
- Maintenance difficulties""" .


# Custom Hooks Standard
:CustomHooks a cs:CodeStandard ;
    cs:name "react/hooks/custom" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Custom hooks should be used when:
- Logic needs to be shared between components
- Component logic becomes complex
- State management needs to be abstracted
- Side effects need to be encapsulated" ;
    cs:dos """# Proper custom hook usage
```typescript
// Example: useLocalStorage
// A hook to sync state with localStorage
function useLocalStorage() {
  // Syncs a value with localStorage and returns getter/setter
}
```

This approach:
- Reduces component complexity
- Enables logic reuse
- Improves testability""" ;
    cs:donts """# Problematic hook patterns
```tsx
// Don't create hooks for simple state
const useCounter = () => {  // Bad: Unnecessary abstraction
  const [count, setCount] = useState(0);
  return { count, setCount };
};

// Don't mix concerns in hooks
const useUserData = () => {  // Bad: Too many responsibilities
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const navigate = useNavigate();
  
  // Authentication
  const login = async () => {/*...*/};
  const logout = async () => {/*...*/};
  
  // Profile management
  const updateProfile = async () => {/*...*/};
  const deleteAccount = async () => {/*...*/};
  
  // Preferences
  const updateSettings = async () => {/*...*/};
  
  return { user, login, logout, updateProfile, /* ... */ };
};
```

These patterns:
- Create unnecessary abstractions
- Mix concerns
- Make testing difficult""" .

# Custom Hooks Structure Standard
:CustomHooksStructure a cs:CodeStandard ;
    cs:name "react/file-structure/hooks" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Custom hooks should be organized by scope: local hooks live in the component folder, global hooks live in a shared hooks directory at the package level. Each hook should have its own folder if complex, with index.ts and types.ts as needed." ;
    cs:dos """
(Do) Organize hooks based on their scope, with local hooks inside the component folder and global hooks in a shared package-level directory.
```
// Good: Local hook for a single component
MyComponent/
  └── useMyHook.ts

// Good: Multiple local hooks for a component
MyComponent/
  └── hooks/
      ├── useFirstHook.ts
      └── useSecondHook.ts

// Good: Global, shared hook
src/
  └── ui/
      └── hooks/
          └── useWindowFitment/
              ├── index.ts
              ├── types.ts
              └── useWindowFitment.ts
```
""" ;
    cs:donts """
(Don't) Place hooks in incorrect locations or mix concerns.
```
// Bad: Global hook inside a component folder
MyComponent/
  └── useWindowFitment.ts

// Bad: Local hook outside its component's folder
src/
  └── ui/
      └── hooks/
          └── useMyComponentHook.ts

// Bad: Mixing unrelated hooks in a single file
src/
  └── ui/
      └── hooks/
          └── all-hooks.ts // Contains useWindowFitment, useAuthentication, etc.
```
""" .

# Context Provider Structure Standard
:ContextProviderStructure a cs:CodeStandard ;
    cs:name "react/file-structure/context" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Context providers should be organized within the component folder. Use Context.tsx for context definition, Provider.tsx for the provider component, and types.ts for context value types." ;
    cs:dos """
(Do) Structure context files within the component folder that provides the context.
```
MyComponent/
  ├── Context.tsx     // Defines the context with createContext()
  ├── Provider.tsx    // The component that provides the context value
  ├── types.ts        // Contains type definitions for the context
  └── hooks/
      └── useMyContextState.ts // Hook to manage the provider's state
```
""" ;
    cs:donts """
(Don't) Mix context logic into single files or place it outside the relevant component folder.
```
// Bad: Context and Provider logic mixed into one file
MyComponent/
  └── ContextAndProvider.tsx

// Bad: Context files located in a generic 'contexts' folder
src/
  └── contexts/
      └── MyComponentContext.ts // Should be inside MyComponent/
```
""" .

# DS Selector Class Standard
:ClassNameDSSelector a cs:CodeStandard ;
    cs:name "react/component/classname-ds-selector" ;
    cs:hasCategory :ReactCategory ;
    cs:description "Every component must include a design system (ds) selector as the first class in its className list. This ensures consistent namespacing and styling across the design system." ;
    cs:dos """
(Do) Always include a ds selector as the first class in the className list:
```tsx
const Button = ({ className, ...props }: ButtonProps) => (
  <button
    className={["ds button", className].filter(Boolean).join(" ")}
    {...props}
  >
    {props.children}
  </button>
);
```

(Do) Use a specific ds selector for each component type:
```tsx
"ds card"
"ds input"
"ds modal"
```
""" ;
    cs:donts """
(Don't) Omit the ds selector from the className list:
```tsx
const Button = ({ className, ...props }: ButtonProps) => (
  <button
    className={[className].filter(Boolean).join(" ")}
    {...props}
  />
); // Bad: No ds selector present
```

(Don't) Place the ds selector after other classes:
```tsx
const Button = ({ className, ...props }: ButtonProps) => (
  <button
    className={[className, "ds button"].filter(Boolean).join(" ")}
    {...props}
  />
); // Bad: ds selector is not first
```
